{
    "fesom2.FESOM2.peakmem_pset_execute": {
        "code": "class FESOM2:\n    def peakmem_pset_execute(self,data_home,npart,integrator):\n        ds = _load_ds(self.datapath)\n        grid = UxGrid(ds.uxgrid, z=ds.coords[\"nz\"], mesh=\"flat\")\n        U = Field(name=\"U\", data=ds.u, grid=grid, interp_method=UxPiecewiseConstantFace)\n        V = Field(name=\"V\", data=ds.v, grid=grid, interp_method=UxPiecewiseConstantFace)\n        U.units = GeographicPolar()\n        V.units = Geographic()\n        UV = VectorField(name=\"UV\", U=U, V=V)\n        fieldset = FieldSet([UV, UV.U, UV.V])\n    \n        lon = np.linspace(2.0,15.0,npart)\n        lat = np.linspace(32.0,19.0,npart)\n    \n        pset = ParticleSet(fieldset=fieldset, pclass=Particle, lon=lon, lat=lat)\n        pset.execute(runtime=runtime, dt=dt, pyfunc=integrator)\n\n    def setup(self,data_home,npart,integrator):\n        # Ensure the dataset is downloaded in the desired data_home\n        # and obtain the path to the dataset\n        self.datapath = download_example_dataset(\"FESOM-baroclinic-gyre\", data_home=data_home)",
        "name": "fesom2.FESOM2.peakmem_pset_execute",
        "param_names": [
            "data_home",
            "npart",
            "integrator"
        ],
        "params": [
            [
                "None"
            ],
            [
                "10000"
            ],
            [
                "<function AdvectionEE>"
            ]
        ],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6980679b7afb765790e5f9e31d623a0cacc9af5cb120ea0a5b09358e5ebe87c7"
    },
    "fesom2.FESOM2.time_load_data": {
        "code": "class FESOM2:\n    def time_load_data(self,data_home,npart,integrator):\n        ds = _load_ds(self.datapath)\n        for i in range(min(ds.coords[\"time\"].size, 2)):\n            u = ds[\"u\"].isel(time=i).compute()\n            v = ds[\"v\"].isel(time=i).compute()\n\n    def setup(self,data_home,npart,integrator):\n        # Ensure the dataset is downloaded in the desired data_home\n        # and obtain the path to the dataset\n        self.datapath = download_example_dataset(\"FESOM-baroclinic-gyre\", data_home=data_home)",
        "min_run_count": 2,
        "name": "fesom2.FESOM2.time_load_data",
        "number": 0,
        "param_names": [
            "data_home",
            "npart",
            "integrator"
        ],
        "params": [
            [
                "None"
            ],
            [
                "10000"
            ],
            [
                "<function AdvectionEE>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "316470285f21be1eecb64c8be982a9a7862441e6a382e23266ae151278ef1eb2",
        "warmup_time": -1
    },
    "fesom2.FESOM2.time_pset_execute": {
        "code": "class FESOM2:\n    def time_pset_execute(self,data_home,npart,integrator):\n        ds = _load_ds(self.datapath)\n        grid = UxGrid(ds.uxgrid, z=ds.coords[\"nz\"], mesh=\"flat\")\n        U = Field(name=\"U\", data=ds.u, grid=grid, interp_method=UxPiecewiseConstantFace)\n        V = Field(name=\"V\", data=ds.v, grid=grid, interp_method=UxPiecewiseConstantFace)\n        U.units = GeographicPolar()\n        V.units = Geographic()\n        UV = VectorField(name=\"UV\", U=U, V=V)\n        fieldset = FieldSet([UV, UV.U, UV.V])\n    \n        lon = np.linspace(2.0,15.0,npart)\n        lat = np.linspace(32.0,19.0,npart)\n    \n        pset = ParticleSet(fieldset=fieldset, pclass=Particle, lon=lon, lat=lat)\n        pset.execute(runtime=runtime, dt=dt, pyfunc=integrator)\n\n    def setup(self,data_home,npart,integrator):\n        # Ensure the dataset is downloaded in the desired data_home\n        # and obtain the path to the dataset\n        self.datapath = download_example_dataset(\"FESOM-baroclinic-gyre\", data_home=data_home)",
        "min_run_count": 2,
        "name": "fesom2.FESOM2.time_pset_execute",
        "number": 0,
        "param_names": [
            "data_home",
            "npart",
            "integrator"
        ],
        "params": [
            [
                "None"
            ],
            [
                "10000"
            ],
            [
                "<function AdvectionEE>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "703872a71cc8c4710d0f894fcd3726901430f0de08a0f76e9797d32ee5afb354",
        "warmup_time": -1
    },
    "moi_curvilinear.MOICurvilinear.peakmem_pset_execute_3d": {
        "code": "class MOICurvilinear:\n    def peakmem_pset_execute_3d(self,data_home,interpolator,chunk,npart):\n    \n    \n        ds = _load_ds(self.datapath,chunk)\n        coords={\n            \"X\": {\"left\": \"x\"},\n            \"Y\": {\"left\": \"y\"},\n            \"Z\": {\"center\": \"deptht\", \"left\": \"depth\"},\n            \"T\": {\"center\": \"time\"},\n        }\n    \n        grid = parcels._core.xgrid.XGrid(xgcm.Grid(ds, coords=coords, autoparse_metadata=False, periodic=False), mesh=\"spherical\")\n    \n        if interpolator == \"XLinear\":\n            interp_method = XLinear\n        else:\n            raise ValueError(f\"Unknown interpolator: {interpolator}\")\n    \n        U = parcels.Field(\"U\", ds[\"U\"], grid, interp_method=interp_method)\n        V = parcels.Field(\"V\", ds[\"V\"], grid, interp_method=interp_method)\n        U.units = parcels.GeographicPolar()\n        V.units = parcels.Geographic()\n        UV = parcels.VectorField(\"UV\", U, V)\n    \n        fieldset = parcels.FieldSet([U, V, UV])\n    \n        pclass = parcels.Particle\n    \n        lon = np.linspace(-10, 10, npart)\n        lat = np.linspace(-30, -20, npart)\n    \n        pset = parcels.ParticleSet(fieldset=fieldset, pclass=pclass, lon=lon, lat=lat)\n    \n        pset.execute(parcels.kernels.AdvectionEE, runtime=runtime, dt=dt, verbose_progress=False)\n\n    def setup(self,data_home,interpolator,chunk,npart):\n        # Ensure the dataset is downloaded in the desired data_home\n        # and obtain the path to the dataset\n        self.datapath = download_example_dataset(\"MOi-curvilinear\", data_home=data_home)",
        "name": "moi_curvilinear.MOICurvilinear.peakmem_pset_execute_3d",
        "param_names": [
            "data_home",
            "interpolator",
            "chunk",
            "npart"
        ],
        "params": [
            [
                "None"
            ],
            [
                "'XLinear'"
            ],
            [
                "256"
            ],
            [
                "10000"
            ]
        ],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "b7d0a9ee1613380ff6904b75046c755489cc4520b37a0e745c2df94b1f2dfaec"
    },
    "moi_curvilinear.MOICurvilinear.time_load_data_3d": {
        "code": "class MOICurvilinear:\n    def time_load_data_3d(self,data_home,interpolator,chunk,npart):\n        \"\"\"Benchmark that times loading the 'U' and 'V' data arrays only for 3-D\"\"\"\n    \n        # To have a reasonable runtime, we only consider the time it takes to load two time levels\n        # and two depth levels (at most)\n        ds = _load_ds(self.datapath,chunk)\n        for j in range(min(ds.coords[\"deptht\"].size,2)):\n            for i in range(min(ds.coords[\"time\"].size, 2)):\n                u = ds[\"U\"].isel(deptht=j,time=i).compute()\n                v = ds[\"V\"].isel(deptht=j,time=i).compute()\n\n    def setup(self,data_home,interpolator,chunk,npart):\n        # Ensure the dataset is downloaded in the desired data_home\n        # and obtain the path to the dataset\n        self.datapath = download_example_dataset(\"MOi-curvilinear\", data_home=data_home)",
        "min_run_count": 2,
        "name": "moi_curvilinear.MOICurvilinear.time_load_data_3d",
        "number": 0,
        "param_names": [
            "data_home",
            "interpolator",
            "chunk",
            "npart"
        ],
        "params": [
            [
                "None"
            ],
            [
                "'XLinear'"
            ],
            [
                "256"
            ],
            [
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cb67754a01b40cf8826fe13ad23adaee2c847cb08d8b399ea9de513c7b35f9a6",
        "warmup_time": -1
    },
    "moi_curvilinear.MOICurvilinear.time_pset_execute_3d": {
        "code": "class MOICurvilinear:\n    def time_pset_execute_3d(self,data_home,interpolator,chunk,npart):\n    \n        ds = _load_ds(self.datapath,chunk)\n        coords={\n            \"X\": {\"left\": \"x\"},\n            \"Y\": {\"left\": \"y\"},\n            \"Z\": {\"center\": \"deptht\", \"left\": \"depth\"},\n            \"T\": {\"center\": \"time\"},\n        }\n    \n        grid = parcels._core.xgrid.XGrid(xgcm.Grid(ds, coords=coords, autoparse_metadata=False, periodic=False), mesh=\"spherical\")\n    \n        if interpolator == \"XLinear\":\n            interp_method = XLinear\n        else:\n            raise ValueError(f\"Unknown interpolator: {interpolator}\")\n    \n        U = parcels.Field(\"U\", ds[\"U\"], grid, interp_method=interp_method)\n        V = parcels.Field(\"V\", ds[\"V\"], grid, interp_method=interp_method)\n        U.units = parcels.GeographicPolar()\n        V.units = parcels.Geographic()\n        UV = parcels.VectorField(\"UV\", U, V)\n    \n        fieldset = parcels.FieldSet([U, V, UV])\n    \n        pclass = parcels.Particle\n    \n        lon = np.linspace(-10, 10, npart)\n        lat = np.linspace(-30, -20, npart)\n    \n        pset = parcels.ParticleSet(fieldset=fieldset, pclass=pclass, lon=lon, lat=lat)\n    \n        pset.execute(parcels.kernels.AdvectionEE, runtime=runtime, dt=dt, verbose_progress=False)\n\n    def setup(self,data_home,interpolator,chunk,npart):\n        # Ensure the dataset is downloaded in the desired data_home\n        # and obtain the path to the dataset\n        self.datapath = download_example_dataset(\"MOi-curvilinear\", data_home=data_home)",
        "min_run_count": 2,
        "name": "moi_curvilinear.MOICurvilinear.time_pset_execute_3d",
        "number": 0,
        "param_names": [
            "data_home",
            "interpolator",
            "chunk",
            "npart"
        ],
        "params": [
            [
                "None"
            ],
            [
                "'XLinear'"
            ],
            [
                "256"
            ],
            [
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a96ae84ff396ac6140f956d1f1405408daf8b8037ca6b1b9e4f34a3f65d77146",
        "warmup_time": -1
    },
    "version": 2
}